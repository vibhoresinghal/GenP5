/* Additional Patterns for PatternFlow */

const AdditionalPatterns = {

    // 7. NEON RINGS
    neonRings: {
        name: 'Neon Rings',
        description: 'Pulsing concentric circles',
        defaults: { ringCount: 8, pulseSpeed: 1, thickness: 3, glow: true, colorMode: 0 },
        controls: [
            { group: 'Rings', icon: 'layers' },
            { name: 'ringCount', label: 'Ring Count', type: 'slider', min: 3, max: 20, step: 1 },
            { name: 'thickness', label: 'Thickness', type: 'slider', min: 1, max: 10, step: 1 },
            { group: 'Animation', icon: 'play' },
            { name: 'pulseSpeed', label: 'Pulse Speed', type: 'slider', min: 0.5, max: 3, step: 0.1 },
            { name: 'glow', label: 'Glow Effect', type: 'toggle' },
            { group: 'Style', icon: 'palette' },
            {
                name: 'colorMode', label: 'Color Palette', type: 'palette', options: [
                    ['#a855f7', '#ec4899', '#06b6d4'], ['#22c55e', '#eab308', '#ef4444'],
                    ['#3b82f6', '#8b5cf6', '#ec4899'], ['#ffffff', '#a1a1aa', '#71717a']
                ]
            }
        ],
        setup: function (p, params, container) {
            const size = Math.min(container.clientWidth - 48, container.clientHeight - 48);
            this.time = 0;
            return p.createCanvas(size, size);
        },
        draw: function (p, params) {
            p.background(10, 10, 11);
            p.translate(p.width / 2, p.height / 2);
            this.time += params.pulseSpeed * 0.02;
            p.noFill();
            const colors = this.getColors(p, params.colorMode);
            const maxR = p.width * 0.45;
            for (let i = 0; i < params.ringCount; i++) {
                const r = (maxR / params.ringCount) * (i + 1);
                const pulse = p.sin(this.time + i * 0.5) * 0.3 + 0.7;
                const c = colors[i % colors.length];
                if (params.glow) {
                    p.stroke(p.red(c), p.green(c), p.blue(c), 50);
                    p.strokeWeight(params.thickness * 4);
                    p.ellipse(0, 0, r * 2 * pulse, r * 2 * pulse);
                }
                p.stroke(c);
                p.strokeWeight(params.thickness);
                p.ellipse(0, 0, r * 2 * pulse, r * 2 * pulse);
            }
        },
        getColors: function (p, m) {
            const palettes = [
                [p.color(168, 85, 247), p.color(236, 72, 153), p.color(6, 182, 212)],
                [p.color(34, 197, 94), p.color(234, 179, 8), p.color(239, 68, 68)],
                [p.color(59, 130, 246), p.color(139, 92, 246), p.color(236, 72, 153)],
                [p.color(255, 255, 255), p.color(161, 161, 170), p.color(113, 113, 122)]
            ];
            return palettes[m] || palettes[0];
        },
        reset: function (p) { this.time = 0; },
        getCode: function (params) { return `// Neon Rings\n// Generated by PatternFlow\nlet time = 0;\nfunction setup() { createCanvas(600, 600); }\nfunction draw() { background(10); translate(width/2, height/2); time += 0.02; noFill(); strokeWeight(${params.thickness}); for(let i=0; i<${params.ringCount}; i++) { let r = (width*0.45/${params.ringCount})*(i+1); let pulse = sin(time + i*0.5)*0.3+0.7; stroke(168,85,247); ellipse(0,0,r*2*pulse,r*2*pulse); } }`; }
    },

    // 8. MATRIX RAIN
    matrixRain: {
        name: 'Matrix Rain',
        description: 'Digital rain effect',
        defaults: { columnCount: 40, speed: 5, fontSize: 14, colorMode: 0 },
        controls: [
            { group: 'Rain', icon: 'sparkles' },
            { name: 'columnCount', label: 'Columns', type: 'slider', min: 20, max: 80, step: 5 },
            { name: 'fontSize', label: 'Font Size', type: 'slider', min: 10, max: 24, step: 2 },
            { group: 'Animation', icon: 'play' },
            { name: 'speed', label: 'Speed', type: 'slider', min: 1, max: 15, step: 1 },
            { group: 'Style', icon: 'palette' },
            {
                name: 'colorMode', label: 'Color Palette', type: 'palette', options: [
                    ['#22c55e', '#4ade80', '#86efac'], ['#06b6d4', '#22d3ee', '#67e8f9'],
                    ['#a855f7', '#c084fc', '#d8b4fe'], ['#f97316', '#fb923c', '#fdba74']
                ]
            }
        ],
        setup: function (p, params, container) {
            const canvas = p.createCanvas(container.clientWidth - 48, container.clientHeight - 48);
            this.columns = [];
            const colW = p.width / params.columnCount;
            for (let i = 0; i < params.columnCount; i++) {
                this.columns.push({ x: i * colW, y: p.random(-500, 0), speed: p.random(3, 8) });
            }
            p.textFont('monospace');
            return canvas;
        },
        draw: function (p, params) {
            p.background(10, 10, 11, 50);
            p.textSize(params.fontSize);
            const colors = this.getColors(p, params.colorMode);
            const colW = p.width / params.columnCount;
            while (this.columns.length < params.columnCount) this.columns.push({ x: this.columns.length * colW, y: p.random(-500, 0), speed: p.random(3, 8) });
            while (this.columns.length > params.columnCount) this.columns.pop();
            for (let col of this.columns) {
                for (let j = 0; j < 20; j++) {
                    const y = col.y - j * params.fontSize;
                    if (y > 0 && y < p.height) {
                        const alpha = p.map(j, 0, 20, 255, 0);
                        const c = colors[j % colors.length];
                        p.fill(p.red(c), p.green(c), p.blue(c), alpha);
                        p.text(String.fromCharCode(0x30A0 + p.floor(p.random(96))), col.x, y);
                    }
                }
                col.y += col.speed * params.speed * 0.3;
                if (col.y > p.height + 300) col.y = p.random(-300, -100);
            }
        },
        getColors: function (p, m) {
            const palettes = [
                [p.color(34, 197, 94), p.color(74, 222, 128), p.color(134, 239, 172)],
                [p.color(6, 182, 212), p.color(34, 211, 238), p.color(103, 232, 249)],
                [p.color(168, 85, 247), p.color(192, 132, 252), p.color(216, 180, 254)],
                [p.color(249, 115, 22), p.color(251, 146, 60), p.color(253, 186, 116)]
            ];
            return palettes[m] || palettes[0];
        },
        reset: function (p, params) { this.columns = []; },
        getCode: function (params) { return `// Matrix Rain - Generated by PatternFlow`; }
    },

    // 9. AURORA BOREALIS
    aurora: {
        name: 'Aurora Borealis',
        description: 'Northern lights simulation',
        defaults: { waveCount: 5, speed: 1, intensity: 0.7, colorMode: 0 },
        controls: [
            { group: 'Aurora', icon: 'waves' },
            { name: 'waveCount', label: 'Wave Layers', type: 'slider', min: 2, max: 10, step: 1 },
            { name: 'intensity', label: 'Intensity', type: 'slider', min: 0.3, max: 1, step: 0.1 },
            { group: 'Animation', icon: 'play' },
            { name: 'speed', label: 'Speed', type: 'slider', min: 0.5, max: 3, step: 0.1 },
            { group: 'Style', icon: 'palette' },
            {
                name: 'colorMode', label: 'Color Palette', type: 'palette', options: [
                    ['#22c55e', '#06b6d4', '#8b5cf6'], ['#ec4899', '#a855f7', '#3b82f6'],
                    ['#eab308', '#22c55e', '#06b6d4'], ['#f472b6', '#c084fc', '#60a5fa']
                ]
            }
        ],
        setup: function (p, params, container) {
            this.time = 0;
            return p.createCanvas(container.clientWidth - 48, container.clientHeight - 48);
        },
        draw: function (p, params) {
            p.background(5, 5, 15);
            this.time += params.speed * 0.005;
            const colors = this.getColors(p, params.colorMode);
            p.noStroke();
            for (let w = 0; w < params.waveCount; w++) {
                const baseY = p.height * 0.3 + w * 30;
                const c = colors[w % colors.length];
                p.fill(p.red(c), p.green(c), p.blue(c), 30 * params.intensity);
                p.beginShape();
                p.vertex(0, p.height);
                for (let x = 0; x <= p.width; x += 10) {
                    const y = baseY + p.noise(x * 0.005, w * 0.5, this.time) * 150 - 50;
                    p.vertex(x, y);
                }
                p.vertex(p.width, p.height);
                p.endShape(p.CLOSE);
            }
        },
        getColors: function (p, m) {
            const palettes = [
                [p.color(34, 197, 94), p.color(6, 182, 212), p.color(139, 92, 246)],
                [p.color(236, 72, 153), p.color(168, 85, 247), p.color(59, 130, 246)],
                [p.color(234, 179, 8), p.color(34, 197, 94), p.color(6, 182, 212)],
                [p.color(244, 114, 182), p.color(192, 132, 252), p.color(96, 165, 250)]
            ];
            return palettes[m] || palettes[0];
        },
        reset: function () { this.time = 0; },
        getCode: function (params) { return `// Aurora Borealis - Generated by PatternFlow`; }
    },

    // 10. BOUNCING BALLS
    bouncingBalls: {
        name: 'Bouncing Balls',
        description: 'Physics-based spheres',
        defaults: { ballCount: 15, gravity: 0.5, bounce: 0.8, size: 30, colorMode: 0 },
        controls: [
            { group: 'Balls', icon: 'sparkles' },
            { name: 'ballCount', label: 'Ball Count', type: 'slider', min: 5, max: 50, step: 1 },
            { name: 'size', label: 'Size', type: 'slider', min: 10, max: 60, step: 5 },
            { group: 'Physics', icon: 'play' },
            { name: 'gravity', label: 'Gravity', type: 'slider', min: 0.1, max: 1.5, step: 0.1 },
            { name: 'bounce', label: 'Bounce', type: 'slider', min: 0.5, max: 0.99, step: 0.01 },
            { group: 'Style', icon: 'palette' },
            {
                name: 'colorMode', label: 'Color Palette', type: 'palette', options: [
                    ['#ef4444', '#f97316', '#eab308'], ['#3b82f6', '#06b6d4', '#10b981'],
                    ['#a855f7', '#ec4899', '#f472b6'], ['#64748b', '#94a3b8', '#cbd5e1']
                ]
            }
        ],
        setup: function (p, params, container) {
            const canvas = p.createCanvas(container.clientWidth - 48, container.clientHeight - 48);
            this.balls = [];
            const colors = this.getColors(p, params.colorMode);
            for (let i = 0; i < params.ballCount; i++) {
                this.balls.push({ x: p.random(p.width), y: p.random(p.height / 2), vx: p.random(-3, 3), vy: 0, color: p.random(colors) });
            }
            return canvas;
        },
        draw: function (p, params) {
            p.background(10, 10, 11);
            while (this.balls.length < params.ballCount) {
                const colors = this.getColors(p, params.colorMode);
                this.balls.push({ x: p.random(p.width), y: 0, vx: p.random(-3, 3), vy: 0, color: p.random(colors) });
            }
            while (this.balls.length > params.ballCount) this.balls.pop();
            for (let ball of this.balls) {
                ball.vy += params.gravity;
                ball.x += ball.vx;
                ball.y += ball.vy;
                if (ball.y > p.height - params.size / 2) { ball.y = p.height - params.size / 2; ball.vy *= -params.bounce; }
                if (ball.x < params.size / 2 || ball.x > p.width - params.size / 2) ball.vx *= -1;
                ball.x = p.constrain(ball.x, params.size / 2, p.width - params.size / 2);
                p.noStroke();
                p.fill(ball.color);
                p.ellipse(ball.x, ball.y, params.size, params.size);
            }
        },
        getColors: function (p, m) {
            const palettes = [
                [p.color(239, 68, 68), p.color(249, 115, 22), p.color(234, 179, 8)],
                [p.color(59, 130, 246), p.color(6, 182, 212), p.color(16, 185, 129)],
                [p.color(168, 85, 247), p.color(236, 72, 153), p.color(244, 114, 182)],
                [p.color(100, 116, 139), p.color(148, 163, 184), p.color(203, 213, 225)]
            ];
            return palettes[m] || palettes[0];
        },
        reset: function (p, params) { this.balls = []; },
        getCode: function (params) { return `// Bouncing Balls - Generated by PatternFlow`; }
    },

    // 11. KALEIDOSCOPE
    kaleidoscope: {
        name: 'Kaleidoscope',
        description: 'Mirror symmetry patterns',
        defaults: { segments: 8, speed: 1, complexity: 5, colorMode: 0 },
        controls: [
            { group: 'Symmetry', icon: 'layers' },
            { name: 'segments', label: 'Segments', type: 'slider', min: 4, max: 16, step: 2 },
            { name: 'complexity', label: 'Complexity', type: 'slider', min: 2, max: 10, step: 1 },
            { group: 'Animation', icon: 'play' },
            { name: 'speed', label: 'Speed', type: 'slider', min: 0.5, max: 3, step: 0.1 },
            { group: 'Style', icon: 'palette' },
            {
                name: 'colorMode', label: 'Color Palette', type: 'palette', options: [
                    ['#a855f7', '#3b82f6', '#06b6d4'], ['#ef4444', '#f97316', '#eab308'],
                    ['#22c55e', '#10b981', '#14b8a6'], ['#ec4899', '#f472b6', '#fda4af']
                ]
            }
        ],
        setup: function (p, params, container) {
            const size = Math.min(container.clientWidth - 48, container.clientHeight - 48);
            this.time = 0;
            return p.createCanvas(size, size);
        },
        draw: function (p, params) {
            p.background(10, 10, 11);
            p.translate(p.width / 2, p.height / 2);
            this.time += params.speed * 0.01;
            const colors = this.getColors(p, params.colorMode);
            p.noFill();
            p.strokeWeight(2);
            for (let s = 0; s < params.segments; s++) {
                p.push();
                p.rotate((p.TWO_PI / params.segments) * s);
                for (let i = 0; i < params.complexity; i++) {
                    const c = colors[i % colors.length];
                    p.stroke(c);
                    const r = 50 + i * 30;
                    const x = p.cos(this.time + i) * r;
                    const y = p.sin(this.time * 1.5 + i) * r * 0.5;
                    p.ellipse(x, y, 20 + p.sin(this.time + i) * 10, 20 + p.cos(this.time + i) * 10);
                }
                p.pop();
            }
        },
        getColors: function (p, m) {
            const palettes = [
                [p.color(168, 85, 247), p.color(59, 130, 246), p.color(6, 182, 212)],
                [p.color(239, 68, 68), p.color(249, 115, 22), p.color(234, 179, 8)],
                [p.color(34, 197, 94), p.color(16, 185, 129), p.color(20, 184, 166)],
                [p.color(236, 72, 153), p.color(244, 114, 182), p.color(253, 164, 175)]
            ];
            return palettes[m] || palettes[0];
        },
        reset: function () { this.time = 0; },
        getCode: function (params) { return `// Kaleidoscope - Generated by PatternFlow`; }
    },

    // 12. LISSAJOUS CURVES
    lissajous: {
        name: 'Lissajous Curves',
        description: 'Harmonic oscillation art',
        defaults: { freqX: 3, freqY: 2, phase: 0, trails: true, colorMode: 0 },
        controls: [
            { group: 'Frequencies', icon: 'waves' },
            { name: 'freqX', label: 'X Frequency', type: 'slider', min: 1, max: 10, step: 1 },
            { name: 'freqY', label: 'Y Frequency', type: 'slider', min: 1, max: 10, step: 1 },
            { name: 'phase', label: 'Phase', type: 'slider', min: 0, max: 3.14, step: 0.1 },
            { group: 'Style', icon: 'palette' },
            { name: 'trails', label: 'Show Trails', type: 'toggle' },
            {
                name: 'colorMode', label: 'Color Palette', type: 'palette', options: [
                    ['#a855f7', '#ec4899', '#f472b6'], ['#06b6d4', '#22d3ee', '#67e8f9'],
                    ['#22c55e', '#4ade80', '#86efac'], ['#fbbf24', '#fcd34d', '#fde68a']
                ]
            }
        ],
        setup: function (p, params, container) {
            const size = Math.min(container.clientWidth - 48, container.clientHeight - 48);
            this.time = 0;
            this.points = [];
            return p.createCanvas(size, size);
        },
        draw: function (p, params) {
            if (params.trails) {
                p.fill(10, 10, 11, 15);
                p.noStroke();
                p.rect(0, 0, p.width, p.height);
            } else {
                p.background(10, 10, 11);
            }
            this.time += 0.02;
            const colors = this.getColors(p, params.colorMode);
            const cx = p.width / 2;
            const cy = p.height / 2;
            const r = p.width * 0.4;
            const x = cx + p.sin(params.freqX * this.time + params.phase) * r;
            const y = cy + p.sin(params.freqY * this.time) * r;
            this.points.push({ x, y, age: 0 });
            if (this.points.length > 500) this.points.shift();
            p.noFill();
            p.strokeWeight(2);
            for (let i = 1; i < this.points.length; i++) {
                const c = colors[i % colors.length];
                const alpha = p.map(i, 0, this.points.length, 50, 255);
                p.stroke(p.red(c), p.green(c), p.blue(c), alpha);
                p.line(this.points[i - 1].x, this.points[i - 1].y, this.points[i].x, this.points[i].y);
            }
        },
        getColors: function (p, m) {
            const palettes = [
                [p.color(168, 85, 247), p.color(236, 72, 153), p.color(244, 114, 182)],
                [p.color(6, 182, 212), p.color(34, 211, 238), p.color(103, 232, 249)],
                [p.color(34, 197, 94), p.color(74, 222, 128), p.color(134, 239, 172)],
                [p.color(251, 191, 36), p.color(252, 211, 77), p.color(253, 230, 138)]
            ];
            return palettes[m] || palettes[0];
        },
        reset: function () { this.time = 0; this.points = []; },
        getCode: function (params) { return `// Lissajous Curves - Generated by PatternFlow`; }
    },

    // 13. STARFIELD
    starfield: {
        name: 'Starfield',
        description: 'Warp speed stars',
        defaults: { starCount: 400, speed: 5, starSize: 3, colorMode: 0 },
        controls: [
            { group: 'Stars', icon: 'star' },
            { name: 'starCount', label: 'Star Count', type: 'slider', min: 100, max: 800, step: 50 },
            { name: 'starSize', label: 'Star Size', type: 'slider', min: 1, max: 6, step: 0.5 },
            { group: 'Animation', icon: 'play' },
            { name: 'speed', label: 'Warp Speed', type: 'slider', min: 1, max: 20, step: 1 },
            { group: 'Style', icon: 'palette' },
            {
                name: 'colorMode', label: 'Color Palette', type: 'palette', options: [
                    ['#ffffff', '#e0e7ff', '#c7d2fe'], ['#fef3c7', '#fde68a', '#fcd34d'],
                    ['#dbeafe', '#bfdbfe', '#93c5fd'], ['#fce7f3', '#fbcfe8', '#f9a8d4']
                ]
            }
        ],
        setup: function (p, params, container) {
            const canvas = p.createCanvas(container.clientWidth - 48, container.clientHeight - 48);
            this.stars = [];
            for (let i = 0; i < params.starCount; i++) {
                this.stars.push({ x: p.random(-p.width, p.width), y: p.random(-p.height, p.height), z: p.random(p.width) });
            }
            return canvas;
        },
        draw: function (p, params) {
            p.background(5, 5, 15);
            p.translate(p.width / 2, p.height / 2);
            while (this.stars.length < params.starCount) this.stars.push({ x: p.random(-p.width, p.width), y: p.random(-p.height, p.height), z: p.width });
            while (this.stars.length > params.starCount) this.stars.pop();
            const colors = this.getColors(p, params.colorMode);
            p.noStroke();
            for (let star of this.stars) {
                star.z -= params.speed;
                if (star.z < 1) { star.z = p.width; star.x = p.random(-p.width, p.width); star.y = p.random(-p.height, p.height); }
                const sx = p.map(star.x / star.z, 0, 1, 0, p.width);
                const sy = p.map(star.y / star.z, 0, 1, 0, p.height);
                const r = p.map(star.z, 0, p.width, params.starSize * 2, 0);
                const c = colors[Math.floor(star.z) % colors.length];
                p.fill(c);
                p.ellipse(sx, sy, r, r);
            }
        },
        getColors: function (p, m) {
            const palettes = [
                [p.color(255, 255, 255), p.color(224, 231, 255), p.color(199, 210, 254)],
                [p.color(254, 243, 199), p.color(253, 230, 138), p.color(252, 211, 77)],
                [p.color(219, 234, 254), p.color(191, 219, 254), p.color(147, 197, 253)],
                [p.color(252, 231, 243), p.color(251, 207, 232), p.color(249, 168, 212)]
            ];
            return palettes[m] || palettes[0];
        },
        reset: function (p) { this.stars = []; },
        getCode: function (params) { return `// Starfield - Generated by PatternFlow`; }
    },

    // 14. NOISE TERRAIN
    noiseTerrain: {
        name: 'Noise Terrain',
        description: '3D wireframe landscape',
        defaults: { resolution: 20, amplitude: 100, speed: 1, colorMode: 0 },
        controls: [
            { group: 'Terrain', icon: 'layers' },
            { name: 'resolution', label: 'Resolution', type: 'slider', min: 10, max: 40, step: 2 },
            { name: 'amplitude', label: 'Amplitude', type: 'slider', min: 30, max: 200, step: 10 },
            { group: 'Animation', icon: 'play' },
            { name: 'speed', label: 'Flow Speed', type: 'slider', min: 0.5, max: 3, step: 0.1 },
            { group: 'Style', icon: 'palette' },
            {
                name: 'colorMode', label: 'Color Palette', type: 'palette', options: [
                    ['#06b6d4', '#0ea5e9', '#3b82f6'], ['#22c55e', '#16a34a', '#15803d'],
                    ['#a855f7', '#9333ea', '#7c3aed'], ['#f97316', '#ea580c', '#dc2626']
                ]
            }
        ],
        setup: function (p, params, container) {
            this.flying = 0;
            return p.createCanvas(container.clientWidth - 48, container.clientHeight - 48, p.WEBGL);
        },
        draw: function (p, params) {
            p.background(10, 10, 11);
            this.flying -= params.speed * 0.02;
            p.rotateX(p.PI / 3);
            p.translate(-p.width / 2, -p.height / 2);
            const colors = this.getColors(p, params.colorMode);
            const scl = p.width / params.resolution;
            let yoff = this.flying;
            for (let y = 0; y < params.resolution; y++) {
                p.beginShape(p.TRIANGLE_STRIP);
                let xoff = 0;
                for (let x = 0; x <= params.resolution; x++) {
                    const z = p.map(p.noise(xoff, yoff), 0, 1, -params.amplitude, params.amplitude);
                    const c = colors[Math.floor(p.map(z, -params.amplitude, params.amplitude, 0, colors.length - 0.01))];
                    p.stroke(c);
                    p.noFill();
                    p.vertex(x * scl, y * scl, z);
                    p.vertex(x * scl, (y + 1) * scl, p.map(p.noise(xoff, yoff + 0.1), 0, 1, -params.amplitude, params.amplitude));
                    xoff += 0.1;
                }
                p.endShape();
                yoff += 0.1;
            }
        },
        getColors: function (p, m) {
            const palettes = [
                [p.color(6, 182, 212), p.color(14, 165, 233), p.color(59, 130, 246)],
                [p.color(34, 197, 94), p.color(22, 163, 74), p.color(21, 128, 61)],
                [p.color(168, 85, 247), p.color(147, 51, 234), p.color(124, 58, 237)],
                [p.color(249, 115, 22), p.color(234, 88, 12), p.color(220, 38, 38)]
            ];
            return palettes[m] || palettes[0];
        },
        reset: function () { this.flying = 0; },
        getCode: function (params) { return `// Noise Terrain - Generated by PatternFlow`; }
    },

    // 15. FIREWORKS
    fireworks: {
        name: 'Fireworks',
        description: 'Explosive particle bursts',
        defaults: { launchRate: 2, particleCount: 100, gravity: 0.1, colorMode: 0 },
        controls: [
            { group: 'Fireworks', icon: 'sparkles' },
            { name: 'launchRate', label: 'Launch Rate', type: 'slider', min: 1, max: 5, step: 1 },
            { name: 'particleCount', label: 'Particles', type: 'slider', min: 50, max: 200, step: 10 },
            { group: 'Physics', icon: 'play' },
            { name: 'gravity', label: 'Gravity', type: 'slider', min: 0.05, max: 0.3, step: 0.01 },
            { group: 'Style', icon: 'palette' },
            {
                name: 'colorMode', label: 'Color Palette', type: 'palette', options: [
                    ['#ef4444', '#f97316', '#eab308'], ['#3b82f6', '#06b6d4', '#22c55e'],
                    ['#ec4899', '#a855f7', '#6366f1'], ['#fbbf24', '#f472b6', '#60a5fa']
                ]
            }
        ],
        setup: function (p, params, container) {
            this.rockets = [];
            this.particles = [];
            return p.createCanvas(container.clientWidth - 48, container.clientHeight - 48);
        },
        draw: function (p, params) {
            p.background(10, 10, 20, 40);
            const colors = this.getColors(p, params.colorMode);
            if (p.random() < params.launchRate * 0.02) {
                this.rockets.push({ x: p.random(p.width), y: p.height, vy: p.random(-15, -10), color: p.random(colors) });
            }
            for (let i = this.rockets.length - 1; i >= 0; i--) {
                const r = this.rockets[i];
                r.y += r.vy;
                r.vy += params.gravity;
                p.stroke(r.color);
                p.strokeWeight(3);
                p.point(r.x, r.y);
                if (r.vy >= 0) {
                    for (let j = 0; j < params.particleCount; j++) {
                        const angle = p.random(p.TWO_PI);
                        const speed = p.random(2, 6);
                        this.particles.push({ x: r.x, y: r.y, vx: p.cos(angle) * speed, vy: p.sin(angle) * speed, color: r.color, life: 255 });
                    }
                    this.rockets.splice(i, 1);
                }
            }
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p2 = this.particles[i];
                p2.x += p2.vx;
                p2.y += p2.vy;
                p2.vy += params.gravity;
                p2.life -= 5;
                p.stroke(p.red(p2.color), p.green(p2.color), p.blue(p2.color), p2.life);
                p.strokeWeight(2);
                p.point(p2.x, p2.y);
                if (p2.life <= 0) this.particles.splice(i, 1);
            }
        },
        getColors: function (p, m) {
            const palettes = [
                [p.color(239, 68, 68), p.color(249, 115, 22), p.color(234, 179, 8)],
                [p.color(59, 130, 246), p.color(6, 182, 212), p.color(34, 197, 94)],
                [p.color(236, 72, 153), p.color(168, 85, 247), p.color(99, 102, 241)],
                [p.color(251, 191, 36), p.color(244, 114, 182), p.color(96, 165, 250)]
            ];
            return palettes[m] || palettes[0];
        },
        reset: function () { this.rockets = []; this.particles = []; },
        getCode: function (params) { return `// Fireworks - Generated by PatternFlow`; }
    },

    // 16. PLASMA
    plasma: {
        name: 'Plasma',
        description: 'Retro plasma effect',
        defaults: { scale: 0.03, speed: 2, colorMode: 0 },
        controls: [
            { group: 'Plasma', icon: 'waves' },
            { name: 'scale', label: 'Scale', type: 'slider', min: 0.01, max: 0.1, step: 0.005 },
            { group: 'Animation', icon: 'play' },
            { name: 'speed', label: 'Speed', type: 'slider', min: 0.5, max: 5, step: 0.5 },
            { group: 'Style', icon: 'palette' },
            {
                name: 'colorMode', label: 'Color Palette', type: 'palette', options: [
                    ['#a855f7', '#ec4899', '#06b6d4'], ['#22c55e', '#eab308', '#ef4444'],
                    ['#3b82f6', '#8b5cf6', '#ec4899'], ['#f97316', '#fbbf24', '#84cc16']
                ]
            }
        ],
        setup: function (p, params, container) {
            this.time = 0;
            const canvas = p.createCanvas(container.clientWidth - 48, container.clientHeight - 48);
            p.pixelDensity(1);
            return canvas;
        },
        draw: function (p, params) {
            this.time += params.speed * 0.02;
            p.loadPixels();
            for (let x = 0; x < p.width; x += 4) {
                for (let y = 0; y < p.height; y += 4) {
                    const v = p.sin(x * params.scale + this.time) + p.sin(y * params.scale + this.time) +
                        p.sin((x + y) * params.scale * 0.5 + this.time) + p.sin(p.sqrt(x * x + y * y) * params.scale + this.time);
                    const hue = (v + 4) / 8;
                    const colors = this.getColors(p, params.colorMode);
                    const c = colors[Math.floor(hue * colors.length) % colors.length];
                    for (let dx = 0; dx < 4; dx++) {
                        for (let dy = 0; dy < 4; dy++) {
                            const idx = 4 * ((y + dy) * p.width + (x + dx));
                            p.pixels[idx] = p.red(c);
                            p.pixels[idx + 1] = p.green(c);
                            p.pixels[idx + 2] = p.blue(c);
                            p.pixels[idx + 3] = 255;
                        }
                    }
                }
            }
            p.updatePixels();
        },
        getColors: function (p, m) {
            const palettes = [
                [p.color(168, 85, 247), p.color(236, 72, 153), p.color(6, 182, 212), p.color(10, 10, 11)],
                [p.color(34, 197, 94), p.color(234, 179, 8), p.color(239, 68, 68), p.color(10, 10, 11)],
                [p.color(59, 130, 246), p.color(139, 92, 246), p.color(236, 72, 153), p.color(10, 10, 11)],
                [p.color(249, 115, 22), p.color(251, 191, 36), p.color(132, 204, 22), p.color(10, 10, 11)]
            ];
            return palettes[m] || palettes[0];
        },
        reset: function () { this.time = 0; },
        getCode: function (params) { return `// Plasma - Generated by PatternFlow`; }
    },

    // 17. METABALLS
    metaballs: {
        name: 'Metaballs',
        description: 'Organic blob simulation',
        defaults: { ballCount: 6, threshold: 1, speed: 2, colorMode: 0 },
        controls: [
            { group: 'Metaballs', icon: 'sparkles' },
            { name: 'ballCount', label: 'Ball Count', type: 'slider', min: 3, max: 12, step: 1 },
            { name: 'threshold', label: 'Threshold', type: 'slider', min: 0.5, max: 2, step: 0.1 },
            { group: 'Animation', icon: 'play' },
            { name: 'speed', label: 'Speed', type: 'slider', min: 0.5, max: 5, step: 0.5 },
            { group: 'Style', icon: 'palette' },
            {
                name: 'colorMode', label: 'Color Palette', type: 'palette', options: [
                    ['#a855f7', '#3b82f6'], ['#22c55e', '#06b6d4'],
                    ['#ef4444', '#f97316'], ['#ec4899', '#f472b6']
                ]
            }
        ],
        setup: function (p, params, container) {
            const canvas = p.createCanvas(container.clientWidth - 48, container.clientHeight - 48);
            this.balls = [];
            for (let i = 0; i < params.ballCount; i++) {
                this.balls.push({ x: p.random(p.width), y: p.random(p.height), vx: p.random(-2, 2), vy: p.random(-2, 2), r: p.random(50, 100) });
            }
            p.pixelDensity(1);
            return canvas;
        },
        draw: function (p, params) {
            while (this.balls.length < params.ballCount) this.balls.push({ x: p.random(p.width), y: p.random(p.height), vx: p.random(-2, 2), vy: p.random(-2, 2), r: p.random(50, 100) });
            while (this.balls.length > params.ballCount) this.balls.pop();
            for (let ball of this.balls) {
                ball.x += ball.vx * params.speed * 0.5;
                ball.y += ball.vy * params.speed * 0.5;
                if (ball.x < 0 || ball.x > p.width) ball.vx *= -1;
                if (ball.y < 0 || ball.y > p.height) ball.vy *= -1;
            }
            const colors = this.getColors(p, params.colorMode);
            p.loadPixels();
            for (let x = 0; x < p.width; x += 4) {
                for (let y = 0; y < p.height; y += 4) {
                    let sum = 0;
                    for (let ball of this.balls) {
                        const d = p.dist(x, y, ball.x, ball.y);
                        sum += ball.r / d;
                    }
                    const c = sum > params.threshold * 10 ? colors[0] : colors[1] || p.color(10, 10, 11);
                    for (let dx = 0; dx < 4; dx++) {
                        for (let dy = 0; dy < 4; dy++) {
                            const idx = 4 * ((y + dy) * p.width + (x + dx));
                            p.pixels[idx] = p.red(c);
                            p.pixels[idx + 1] = p.green(c);
                            p.pixels[idx + 2] = p.blue(c);
                            p.pixels[idx + 3] = 255;
                        }
                    }
                }
            }
            p.updatePixels();
        },
        getColors: function (p, m) {
            const palettes = [
                [p.color(168, 85, 247), p.color(10, 10, 11)],
                [p.color(34, 197, 94), p.color(10, 10, 11)],
                [p.color(239, 68, 68), p.color(10, 10, 11)],
                [p.color(236, 72, 153), p.color(10, 10, 11)]
            ];
            return palettes[m] || palettes[0];
        },
        reset: function () { this.balls = []; },
        getCode: function (params) { return `// Metaballs - Generated by PatternFlow`; }
    },

    // 18. CIRCUIT BOARD
    circuitBoard: {
        name: 'Circuit Board',
        description: 'Digital circuit patterns',
        defaults: { gridSize: 30, traceSpeed: 3, density: 0.3, colorMode: 0 },
        controls: [
            { group: 'Circuit', icon: 'link' },
            { name: 'gridSize', label: 'Grid Size', type: 'slider', min: 15, max: 50, step: 5 },
            { name: 'density', label: 'Density', type: 'slider', min: 0.1, max: 0.6, step: 0.05 },
            { group: 'Animation', icon: 'play' },
            { name: 'traceSpeed', label: 'Trace Speed', type: 'slider', min: 1, max: 10, step: 1 },
            { group: 'Style', icon: 'palette' },
            {
                name: 'colorMode', label: 'Color Palette', type: 'palette', options: [
                    ['#22c55e', '#4ade80'], ['#06b6d4', '#22d3ee'],
                    ['#a855f7', '#c084fc'], ['#f97316', '#fb923c']
                ]
            }
        ],
        setup: function (p, params, container) {
            const canvas = p.createCanvas(container.clientWidth - 48, container.clientHeight - 48);
            this.traces = [];
            this.nodes = [];
            const cols = Math.floor(p.width / params.gridSize);
            const rows = Math.floor(p.height / params.gridSize);
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (p.random() < params.density) {
                        this.nodes.push({ x: i * params.gridSize + params.gridSize / 2, y: j * params.gridSize + params.gridSize / 2 });
                    }
                }
            }
            return canvas;
        },
        draw: function (p, params) {
            p.background(10, 15, 10);
            const colors = this.getColors(p, params.colorMode);
            p.stroke(colors[0]);
            p.strokeWeight(2);
            if (p.random() < 0.02 && this.nodes.length > 1) {
                const start = p.random(this.nodes);
                const end = p.random(this.nodes);
                if (start !== end) {
                    this.traces.push({ x1: start.x, y1: start.y, x2: end.x, y2: end.y, progress: 0 });
                }
            }
            for (let trace of this.traces) {
                trace.progress += params.traceSpeed * 0.02;
                if (trace.progress > 1) trace.progress = 1;
                const midX = (trace.x1 + trace.x2) / 2;
                const cx = trace.x1 + (midX - trace.x1) * Math.min(trace.progress * 2, 1);
                const cy = trace.y1;
                const ex = midX + (trace.x2 - midX) * Math.max((trace.progress - 0.5) * 2, 0);
                const ey = trace.y1 + (trace.y2 - trace.y1) * Math.max((trace.progress - 0.5) * 2, 0);
                p.stroke(colors[0]);
                if (trace.progress <= 0.5) {
                    p.line(trace.x1, trace.y1, cx, cy);
                } else {
                    p.line(trace.x1, trace.y1, midX, trace.y1);
                    p.line(midX, trace.y1, ex, ey);
                }
            }
            this.traces = this.traces.filter(t => t.progress < 1);
            p.fill(colors[1] || colors[0]);
            p.noStroke();
            for (let node of this.nodes) {
                p.ellipse(node.x, node.y, 6, 6);
            }
        },
        getColors: function (p, m) {
            const palettes = [
                [p.color(34, 197, 94), p.color(74, 222, 128)],
                [p.color(6, 182, 212), p.color(34, 211, 238)],
                [p.color(168, 85, 247), p.color(192, 132, 252)],
                [p.color(249, 115, 22), p.color(251, 146, 60)]
            ];
            return palettes[m] || palettes[0];
        },
        reset: function (p, params) { this.traces = []; this.nodes = []; },
        getCode: function (params) { return `// Circuit Board - Generated by PatternFlow`; }
    }
};

// Merge additional patterns into main Patterns object
Object.assign(Patterns, AdditionalPatterns);
